# Application 2 Analysis

### Question 1 Polling vs. Interrupt:
Using an ISR + semaphore is more effective than polling because polling wastes CPU power by constantly checking if the status of the button has changed. When the ISR and semaphore is used the CPU does not check for a status change because the hardware is used to alert the CPU that the status of the button has changed. After receiving the alert the ISR is called and then the task is triggered. This process does not waste CPU computations and only uses the CPU when the hardware is triggered from the button press. Polling can also miss when the status changes if the button is pressed too fast, which could cause a button press to be ignored resulting in the task failing to run.

### Question 2 ISR Design:
An ISR must use the “FromISR” API variant because many FreeRTOS API functions perform actions that are not valid inside of an ISR. For example, if you wanted to put the ISR in a blocked state, the API function call would not work within an ISR because the API is not being called from a task so there is no calling task to be placed in a block state. If you tried running a regular blocking API call from an ISR the API would have nothing to put in a blocked state and the operation would be invalid possibly causing the code to crash or behave unexpectedly. 

### Question 3 Real-Time Behavior:
When the interrupt is fired the ISR preempts the sensor task because hardware interrupts have a higher priority than FreeRTOS tasks. Inside the ISR the semaphore is given to unblock the logger task indicating that it is ready to run. After doing that the ISR calls the portYIELD and checks if the logger task is higher priority than the task that was previously running, which in this case would be the sensor task. Since the logger task has a higher priority than the sensor task when the ISR function call ends the scheduler performs a context switch and the logger task will run until completion followed by the next highest priority task.

### Question 4 Core Affinity:
If the tasks were not pinned to a single core then the ISR and tasks could perform on different cores causing nondeterministic timing and potential race conditions to occur within our system. For example, if a button press triggers an interrupt on core 1 then the ISR will give the semaphore for the logger task indicating that it is ready to run. At this point the scheduler has to decide which core the logger task will run on. If no tasks are running on core 1 then the logger task can run immediately, but if the core is busy the scheduler may choose core 0 for the logger task to run on. This nondeterministic behavior may cause small delays and unpredictable behavior we don't want. That is why pinning all the tasks to 1 core is useful for this lab, it prevents nondeterministic behavior and allows us to see how the ISR and semaphores behave with FreeRTOS tasks. Another behavior that may occur due to not pinning the cores is a race condition. If the ISR is triggered on core 1 and the semaphore is given to the logger task while the sensor task is running on core 0, then both tasks may be trying to access the data at the same time. This could lead to the logger task getting incorrect and outdated data which would result in an incorrect output. Pinning the tasks to one core would also prevent because we know only one core is trying to access data at a time. 

### Question 5 Light Sensor Logging: 
In my code I use a mutual exclusion to prevent the sensor task and the logger task from conflicting in regard to the buffer. In the sensor task a semephoreTake is used and checks the mutual exclusion before adding lux values to the before. In the logger function a semephoreTake is used copying the lux buffer. Doing this makes sure that only one task is accessing and editing the buffer at a time ensuring safe data practices. If the logger tries accessing the buffer while the sensor is in the middle of writing to the buffer this could cause the logger to read partially updated data, resulting in incorrect readings and calculations. The mutual exclusion prevents this from happening because if the sensor was in the middle of writing the logger task would be denied access until the sensor task unblocked the mutual exclusion. For a more robust design, techniques like double-buffering or using atomic operations could be employed.

### Question 6 Task Priorities:
If the logger task had a lower priority than the blink task the button press would result in different behavior. When the ISR gives the semaphore this signals that the logger task is ready to run. Because FreeRTOS uses preemptive scheduling, the now higher priority blink task will continue running and the logger task will not run until the blink task blocks or yields. This means that the log dump will not happen instantly because it isn't the highest priority task anymore. 

### Question 7 Resource Usage: 
Keeping ISR’s short is very important to keep the system from missing deadlines. If an ISR takes too long it can prevent other high priority ISR tasks from running causing missed deadlines. For example, if the button press takes 2 seconds to execute and a second button press occurs 1 second after the first then the second interrupt cannot be serviced until the first interrupt completes execution. This introduces nondeterministic behaviors and delays that could cause missed deadlines. Another reason to keep ISR’s short is because if it is too long it can starve lower priority FreeRTOS tasks from running. Since hardware interrupts have a higher priority than FreeRTOS tasks, if the ISR has a long execution time it will prevent those tasks from running and potentially cause deadlines to be missed. In this lab the ISR uses a semaphore to run the logger task almost immediately which allows the other tasks in the system to continue running on time. 

### Question 8 Chapter Connections:
In “Mastering the FreeRTOS Kernel” Ch. 7 I used the concept of “FromISR” to ensure that my code inside the ISR worked as I intended. In the chapter it says “FreeRTOS solves this problem by providing two versions of some API functions; one version for use from tasks, and one version for use from ISRs. Functions intended for use from ISRs have "FromISR" appended to their name.”. Using this information I knew that if I was writing code inside the ISR to make sure it was appended with FromISR if applicable to have my code function as intended. 