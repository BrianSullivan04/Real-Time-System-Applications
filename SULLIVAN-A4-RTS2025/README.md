# Application 1 Analysis
### Question 1 Signal Discipline:

A button press will trigger the ISR, which gives the binary semaphore dedicated for button presses. This action unblocks the event handler task allowing the system to process the button press which will either start or stop the heart beat monitor system. The button press ultimately triggers the ISR which quickly tells the system to run the highest priority task which in our case is the event handler where the button press is then handled immediately. There is a 200ms debounce in the button press so if the button is pressed multiple times before that 200ms those presses will be ignored. If a counting semaphore was used then multiple button presses would still not affect the system within 200ms, but if multiple button presses happened before the system could handle the presses then they would queue and occur after the system handled each button press. This could cause unpredictable behavior since rapid presses might cause the system to toggle multiple times, which makes it uncertain what the final state the heartbeat monitor would end up in since we don't know what was queued last.

### Question 2 Event Flood Handling:

The system reliably logged when the bpm is stable and unstable because of the use of a counting semaphore. So when I rapidly switched between stable and unstable I saw the console print its error message and safety messages correctly and saw the red and green LED operate as expected which is RED on during unstable bpm with no green blinking and green steadily blinking with no red LED when stable bpm. The counting semaphore ensures this because whenever an unstable bpm is detected the semaphore is given which increments the semaphore count by 1. The event handler then takes the semaphore which decrements the semaphore counter. The max semaphore is set to 10 which is unlikely to be reached, so every time an unsafe bpm is measured that response is handled with a counting semaphore and queued if another unsafe response is still being processed. If a binary semaphore was used then after the first unsafe bpm detection if there was another one while the first one was being handled it would be missed since the semaphore would not have been reset causing system failure. 

### Question 3 Protecting Shared Output:

When I removed the xPrintMutex from my code this allowed two tasks to write simultaneously which resulted in overlapping text in the console. The heart rate reading would overlap with the critical BPM warning in the console. Mutex matters because it ensures that only one task can access shared output at a time. This is important because if one task is changing a variable, but another task accesses it at the same time then the other task will receive out of date data since it was about to be changed by the first task. Mutex ensures that if the first task has access to the shared data then the second task cannot edit it until it is done computing the shared data. In our example if heartbeat logs outputted incorrect data because the shared data was not mutually exclusive then we could miss seeing valuable data used to determine a patient's health. 

### Question 4 Scheduling and Preemption:

Yes, the task priorities worked as expected in my system. A button press triggers the ISR which has the highest priority and when the ISR is triggered all other tasks are preempted until it is complete. The ISR then gave the semaphore which unblocked the event handler task which had the highest priority and even if the heartbeat LED was supposed to blink or the heart rate was supposed to print the event handler task preempted it and the button press caused the system to completely stop which shows that the priorities worked as expected. During busy periods such as when the bpm switches from stable to unstable repeatedly the green LED may blink slightly off schedule because it is being preempted by the event handler task.

### Question 5 Timing and Responsiveness: 

I immediately used vTaskDelayUntil() because it provides precise timing rather than the relative timing given by vTaskDelay(). In my code vTaskDelayUntil() is used in timing when the green LED blinks and when the sensor collects data. Having these be precise is important because if the sensor collects data in unpredictable times it could miss important shifts in data causing the system to not work as intended. I would not change to vTaskDelay() because it can cause drift over time, an error that can be avoided by using vTaskDelayUntil().

### Question 6 Theme Integration:

My system represents a heartbeat monitor that detects when a patients heartbeat is too high or too low. It also has an emergency stop button. The green LED represents a safe heart rate for the patient while the red LED represents an unsafe heartbeat. The heartbeat task flashes the green LED every 1000ms to show all is well with the patient. The sensor task is used to collect heartbeat data and detect if the heartbeat is at a safe or unsafe level. Heartbeat data is collected every 100ms. The event handler task is used when something happens in the system and it generates the correct response according to what happened in the system. It handles a button press, unsafe bpm detection and bpm stabilization events and is given the highest priority. The binary semaphore used for the button press represents an emergency control being activated and the counting semaphore represents a queue of medical alerts that must be addressed in order. Synchronization is life critical because if a heartbeat is missed or a log is incorrectly printed then it could cause serious injuries or lost life that would otherwise be preventable if the system worked as intended. 